CAN Translation Module
=========================

## Description

The CAN translation module code runs on an Arduino-compatible microcontroller
connected to one or more CAN buses. It receives either all CAN messages or a
filtered subset, performs any unit conversion or factoring required and outputs
a generic version to a USB interface.

For more details, see the [OpenXC website](http://openxcplatform.com/developers/vehicle-interface/hardware.html).

## Installation

Building the source for the CAN translator for the chipKIT microcontroller
requires the [MPIDE][] and the CAN and USB libraries for the network sheild,
provided by Microchip. Download these from the bottom of the [Max32 page][] and
extract them to your MPIDE sketchbook directory in a subdirectory named
`libraries`. It should look like this:

    - /Users/me/sketchbook/
    ---- libraries/
    -------- chipKITUSBDevice/
            ... other libraries


If you plan to use the `reader.py` testing program, you will need to install
the system library `libusb` and the Python package `pyusb`. In OS X, `libusb`
can be installed with [homebrew][]. In Ubuntu, it can be installed with `sudo
apt-get install libusb-0.1.4`. On either platform, `pyusb` can be installed with
`sudo easy_install pyusb` or `sudo pip install pyusb`. (`pip` is the newer
Python package manager and is preferrable, but it doesn't come installed out of
the box in OS X. It's easy to install it (`sudo easy_install pip`) but not
required.)

[MPIDE]: https://github.com/chipKIT32/chipKIT32-MAX/downloads
[Max32 page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,895&Prod=CHIPKIT-MAX32
[homebrew]: http://mxcl.github.com/homebrew/

### GUI Building

If you're using the MPIDE to compile and you get a whole mess of errors stemming
from the chipKIT libraries, make sure you have the "chipKIT Max32" selected in
MPIDE under Tools -> Board.

If you're using Mac OS X, make sure to install the FTDI driver that comes with
the MPIDE download. The chipKIT uses a different FTDI chip, so even if you've
used the Arduino before, you still need to install this driver.

### Command Line Building

Alternatively, you can use GNU Make to compile and upload code to the
device. You still need to download and extract the MPIDE someplace, as it
contains the PIC32 toolchain, but you don't have to use the GUI.

This method requires that you clone the [arduino.mk]() repository someone on
your computer. This contains Makefile definitions common to Arduino and chipKIT
platforms.

You also need to set a few environment variables (e.g. in your .bashrc) for this
method (make sure to change these defaults if your system is different!):

    # Path to the extracted MPIDE folder (this is correct for OS X)
    export ARDUINO_DIR=/Applications/Mpide.app/Contents/Resources/Java

    # Path to the MPIDE sketchbook directory. Check in the MPIDE preferences
    # if you don't know this path offhand - this is the default for OS X.
    export ARDUINO_SKETCHBOOK=$HOME/Documents/Arduino

    # Path to the `arduino.mk` cloned repository
    export ARDUINO_MAKEFILE_HOME=$HOME/projects/arduino.mk

Optionally, set the `ARDUINO_PORT` variable if the serial emulator doesn't
show up as `/dev/ttyUSB*` (in Linux) or `/dev/tty.usbserial*` (in Mac OS X).

Once this is set up, run `make` to compile the sketch and `make upload` to
upload the sketch to the board.

[arduino.mk]: https://github.com/peplin/arduino.mk

## Compiling and Uploading

Once the libraries are installed and you have the `cantranslator` sketch open in
MPIDE, you'll notice that it won't compile - it's missing the definition of a
`decodeCanMessage` function. This is the piece you must implement yourself, or
by following the input specification designed here, have auto-generated.

The preferred method is the auto-generation script - it accepts JSON input that
defines the CAN messages and signals of interest and rewrites it as C data
structures, ready to be downloaded to the device. Check the "Input
Specification" section for the details of the input format.

Once you have one or more input JSON files, run the `generate_source.py` script
to create a file that defines `decodeCanMessage`:

    ./generate_code.py --json signals.json > signals.pde

Drop the new `signals.pde` file in the `cantranslator` sketch folder, and it
should now compile.

If you have multiple CAN buses and want to define their signals and messages in
separate files, just pass multiple JSON files:

    ./generate_code.py --json highspeed.json --json mediumspeed.json > signals.pde

Note that the JSON files are parsed and merged, so if you want to define custom
handlers and states separately from the signal definition itself, you can store
them in separate files and they will be merged on import.

### Uploading a Pre-built Binary

Updates to the cantranslator may be distributed as precompiled binaries, e.g. if
they are distributed by an OEM who does not wish to make the CAN signals public.

In that case, you will have a .hex file and can use the `upload_hex.sh` script
to update your device.

    $ ./upload_hex new-version.hex

This script requires that MPIDE is installed, and the environment variable
`ARDUINO_DIR` points to the MPIDE directory (see the "Command Line Building"
section of the [README][cantranslator] for details). If you have an alternative
`avrdude` you wish to use instead, you can modify the upload.sh script
accordingly.

## Input Specification

The code in this repository requires a list of CAN messages with details of the
signals of interest, and their corresponding generic versions. The input format
is a JSON object like this:

    {"0x102": {
        "speed": 500000,
        "messages": {
            "ECM_z_5D2": {
                "signals": {
                    "StrAnglAct": {
                        "human_signal_name": "Steering wheel angle",
                        "generic_name": "SteeringWheelAngle",
                        "bit_position": 52,
                        "bit_size": 12,
                        "factor": 0.15392,
                        "offset": 0,
                        "value_handler": "float handleSteeringWheelAngle"},
                    "StrAnglSign": {
                        "human_signal_name": "Steering wheel angle sign",
                        "generic_name": "steering_angle_sign",
                        "value_handler": "float ignoreHandler",
                        "bit_position": 52,
                        "bit_size": 12},
                    "EngSpd": {
                        "generic_name": "engine_speed",
                        "send_frequency": 15,
                        "bit_position": 12,
                        "bit_size": 8}
                    },
                    "GrshftPos": {
                        "human_signal_name": "Gearshift Position",
                        "generic_name": "GearshiftPosition",
                        "bit_position": 41,
                        "bit_size": 0,
                        "states": {
                            "FIRST": 1,
                            "SECOND": 2,
                            "THIRD": 3,
                            "FOURTH": 4,
                            "REVERSE": 5,
                            "NEUTRAL": 6
                        }
                    },
                    "StrAnglErr": {
                        "value_handler": "float ignoreHandler"
                    }
                },
                "handler": "handleSteeringWheelMessage"
            },
            "BrkSt": {
                "signals": {
                    "BrakePedalPosition": {
                        "generic_name": "brake_pedal_status",
                        "send_same": false,
                        "value_handler": "bool booleanHandler",
                        "bit_position": 0,
                        "bit_size": 0
                    }
                }
            }
        }
    }}

This is a list of CAN buses (the `0x102` is the unique bus address), messages in
each bus and a list of signals within each message. The `speed` attribute on the
bus is the CAN bus speed in Kbps. The attributes of a signal are:

`name` - The official name of the signal - often a terse spelling.
    Optional - just used to be able to reference back to original documentation
    from this list.

`human_signal_name` - A more friendly, human readable version of the signal's
    name. Optional - just used in comments so the generated source is clearer.

`generic_name` - The name of the associated generic signal name (from the OpenXC
    specification) that this should be translated to. Optional - if not
    specified, the signal is read and stored in memory, but not sent to the
    output bus. This is handy for combining the value of multiple signals into a
    composite measurement such as steering wheel angle with its sign.

`bit_position` - The staring bit position of this signal within the message.

`bit_size` - The width in bits of the signal.

`factor` - The signal value is multiplied by this if set. Optional.

`offset` - This is added to the signal value if set. Optional.

`value_handler` - The return type and name of a function that will be compiled
    with the sketch and should be applied to the signal's value after the normal
    translation. Optional - see the "Custom Handlers" section for more.

`handler` - The name of a function that will be compiled with the sketch
    and should be applied to the entire raw message value. No other operations
    are performed on the data if this type of handler is used. Optional - see
    the "Custom Handlers" section for more.

`ignore` - Setting this to `true` on a signal will silence output of that
    signal. The translator will not monitor the signal nor store any of its
    values. This is useful if you are using a custom handler for an entire
    message, want to silence the normal output of the signals it handles, and
    you don't need the translator to keep track of the values of any of the
    signals separately. If you need to use the previously stored values of any
    of ths signals, you can use the `ignoreHandler` as a value handler for the
    signal.

`states` - For state values, this is a mapping between the raw states (usually
    an integer) and the corresponding state in the generic signal.

`send_frequency` - Some CAN signals are sent at a very high frequency, likely
    more often than will ever be useful to an application. This attribute
    defaults to `1` meaning that `1/1` (i.e. 100%) of the values for this signal
    will be processed and sent over USB. Increasing the value will reduce the
    number of messages that are sent - a value of `10` means that only `1/10`
    messages (i.e. every 10th message) is processed. You don't want to combine
    this attribute with `send_same` or else you risk missing a status change
    message if wasn't one of the messages the translator decided to let through.

`send_same` - By default, all signals are process and sent over USB every time
    they are received on the CAN bus. By setting this to `false`, you can force
    a signal to be sent only if the value has actually changed. This works best
    with boolean and state based signals.

## Custom Handlers

The default handler for each signal is a simple passthrough, translating the
signal's ID to an abstracted name (e.g. `SteeringWheelAngle`) and its value from
engineering units to something more usable. Some signals require additional
processing that you may wish to do within the translator and not on the host
device. Other signals may need to be combined to make a composite signal that's
more meaningful to developers.

An good example is steering wheel angle. For an app developer to get a value
that ranges from e.g. -350 to +350, we need to combine two different signals -
the angle and the sign. If you want to make this combination happen inside the
translator, you can use a custom handler.

You may also need a custom handler to return a value of a type other than float.
A handler is provided for dealing with boolean values, the `booleanHandler` - if
you specify that as your signal's `value_handler` the resulting JSON will
contain `true` for 1.0 and `false` for 0.0. If you want to translate integer
state values to string names (for parsing as an enum, for example) you will need
to write a value handler that returns a `char*`.

There are two levels of custom handlers:

* Message handlers - use these for custom processing of the entire CAN message.
* Value handlers - use these for making non-standard transformations to a signal
  value

For this example, we want to modify the value of `SteeringWheelAngle` by setting
the sign positive or negative based on the value of the other signal
(`StrAnglSign`). Every time a CAN signal is received, the new value is stored in
memory. Our custom handler `handleSteeringWheelAngle` will use that to adjust
the raw steering wheel angle value.

    float handleSteeringWheelAngle(CanSignal* signal, CanSignal* signals,
            int signalCount, float value, bool* send) {
        if(signal->lastValue == 0) {
            // left turn
            value *= -1;
        }
        return value;
    }

The valid return types for value handlers are `bool`, `float` and `char*` - the
function prototype must match one of:

    char* customHandler(CanSignal* signal, CanSignal* signals, int signalCount,
            float value, bool* send);

    float customHandler(CanSignal* signal, CanSignal* signals, int signalCount,
            float value, bool* send);

    bool customhandler(cansignal* signal, cansignal* signals, int signalCount,
            float value, bool* send);

where `signal` is a pointer to the `CanSignal` this is handling, `signals` is a
an array of all signals, `value` is the raw value from CAN and `send` is a flag
to indicate if this should be sent over USB.

The `bool* send` parameter is a pointer to a `bool` you can flip to `false` if
this signal value need not be sent over USB. This can be useful if you don't
want to keep notifying the same status over and over again, but only in the
event of a change in value (you can use the `lastValue` field on the CanSignal
object to determine if this is true).

A known issue with this method is that there is no guarantee that the last value
of another signal arrived in the message or before/after the value you're
current modifying. For steering wheel angle, that's probably OK - for other
signals, not so much.

If you need greater precision, you can provide a custom handler for the entire
message to guarantee they arrived together. You can generate 0, 1 or many
translated messages from one call to your handler function.

    void handleSteeringWheelMessage(int messageId, uint8_t* data,
            CanSignal* signals, int signalCount, USBDevice* usbDevice) {
        float steeringWheelAngle = decodeCanSignal(&signals[1], data);
        float steeringWheelSign = decodeCanSignal(&signals[2], data);

        float finalValue = steeringWheelAngle;
        if(steeringWheelSign == 0) {
            // left turn
            finalValue *= -1;
        }

        char* message = generateJson(signals[1], finalValue);
        sendMessage(usbDevice, (uint8_t*) message, strlen(message));
    }

Using a custom message handler will not stop individual messages for each signal
from being output. To silence them but still store their values in
`signal->lastvalue` as they come in, specify the special `ignoreHandler` as the
`value_handler` for signals don't want to double send. The reason we don't do
this automatically is that not all signals in a msesage are always handled by
the same message handler.

## Sketch Generation

With this JSON list in hand, you next need to generate the C source code that
defines a `decodeCanMessage` function that can process the signals you've
defined. The generated source is a conversion of your JSON to an array of
C-structs, ready to be read by the translator at runtime.

To generate code, we've provided the `generate_code.py` script. Use it like so:

    $ generate_code.py signals.json > cantranslator/signals.pde

then rebuild your sketch - everything should build properly now.

Don't add anything else to this file - it's derivative of the master JSON, and
should be able to be wiped and recreated at any time.

### Canoe

If you use Canoe to store your "gold standard" CAN signal definitions, you may
be able to use the included `xml_to_json.py` script to make your JSON for you.
First, export the Canoe .dbc file as XML. Run the conversion script like this:

    $ xml_to_json.py signals.xml signal_mapping.txt build/signals.json

The `signal_mapping.txt` file is a simple mapping of the signal names that we
are looking for in the XML and a unique numerical ID to associate it
with.

## Output Specification

The microcontroller has a second USB controller operating in USB device mode. It
sends the generic vehicle data over via bulk USB transfer as packed JSON.

If USB throughput becomes an issue, the wire format can be optimized in two
ways:

* Use previously agreed upon numeric identifiers for signals instead of English
  names.
* Serialize to a binary protocol with Apache Thrift, or Google Protocol
  Buffers or ASN.1.

There are two valid message types - single valued and event.

### Single Valued

The expected format of a single valued message is:

    {"name": "SteeringWheelAngle", "value": 45}

### Event

The expected format of an event message is:

    {"name": "SteeringWheelAngle", "value": "up", "event": "pressed"}

This format is good for something like a button even, where there are two
discrete pieces of information in the measurement.

## Viewer

The `reader.py` Python program in this repository can be used to view the output
of the CAN translator over micro-USB. Just plug it in and run the script with
the `--verbose` flag to have all messages parsed and printed to stdout.

    $ python reader.py -v

It may also be neccessary to check the current version of the software you have
on a CAN translator - the `--version` flag will tell you that.

    $ python reader.py --version
    Device is running version 1.0

### Dependencies

The `reader.py` script requires the `pyusb` Python library to be installed along
with a backing system library for accessing USB devices. `libusb-1.0` is the
recommended library.

In OS X, the best way to install `libusb-1.0` is with
[homebrew](http://mxcl.github.com/homebrew/). `pyusb` can be installed on
Linux/OS X using `easy_install` or `pip`.

    $ sudo pip install pyusb

    or

    $ sudo easy_install pyusb

## Traces

You can record a trace of JSON messages from the CAN reader for use in testing.
Plug the CAN translator's micro-USB port into a computer and run the `reader.py`
program with the `--dump` flag to print all raw JSON messages to stdout.
Redirect this to a file, and you've got your trace. This can be used directly
by the openxc-android library, for example.

    $ python reader.py -d > vehicle-data.trace

## API

See the [OpenXC][] website for a list of officially supported
[signal names](http://openxcplatform.com/developers/vehicle-interface/translation-specs.html).

## Test Suite

The non-chipKIT code in this repository includes a small test suite that uses
the [check][] library. After installing that library, run the test suite like
so:

    cantranslator/ $ make test

The [check][] library can be installed in Ubuntu Linux quite easily:

    $ sudo apt-get install check

and in Mac OS X, it's available through [homebrew][]:

    $ brew install check

[check]: http://check.sourceforge.net
[homebrew]: http://mxcl.github.com/homebrew/

## License

This source code is available under the BSD license.
