CAN Translation Module
=========================

## Description

The CAN translation module code runs on an Arudino-compatible microcontroller
connected to one or more CAN buses. It receives either all CAN messages or a
filtered subset, performs any unit conversion or factoring required and outputs
a generic version to a USB interface.

## Installation

If you have a chipKIT Max32, the source can be built and uploaded using the
latest version of [MPIDE][] for your platform.

You also need the chipKIT network shield libraries (provided by Microchip).
Download these from the bottom of the [Max32 page][] and extract them to your
MPIDE sketchbook directory in a subdirectory named `libraries`. It should look
like this:

    - /Users/me/sketchbook/
    ---- libraries/
    -------- chipKITUSBDevice/
            ... other libraries

[MPIDE]: https://github.com/chipKIT32/chipKIT32-MAX/downloads
[Max32 page]: http://digilentinc.com/Products/Detail.cfm?NavPath=2,719,895&Prod=CHIPKIT-MAX32.

### Command Line Building

Alternatively, you can use GNU Make to compile and upload code to the
device. You still need to download and extract the MPIDE someplace, as it
contains the PIC32 toolchain, but you don't have to use the GUI.

This method requires that you clone the [arduino.mk]() repository someone on
your computer. This contains Makefile definitions common to Arduino and chipKIT
platforms.

You also need to set a few environment variablse (e.g. in your .bashrc) for this
method:

`ARDUINO_HOME` - the path to the extracted MPIDE folder.

`ARDUINO_SKETCHBOOK` - the path to the MPIDE sketchbook directory. Check in the
	MPIDE preferences if you don't know this path offhand.

`ARDUINO_MAKEFILE_HOME` - the path to the `arduino.mk` cloned repository

Once this is set up, run `make` to compile the sketch and `make upload` to
upload the sketch to the board.

[arduino.mk]: https://github.com/peplin/arduino.mk

## Compiling and Uploading

Once the libraries are installed and you have the `cantranslator` sketch open in
MPIDE, you'll notice that it won't compile - it's missing the definition of a
`decodeCanMessage` function. This is the piece you must implement yourself, or
by following the input specification designed here, have auto-generated.

The preferred method is the auto-generation script - it accepts JSON input that
defines the CAN messages and signals of interest and rewrites it as C data
structures, ready to be downloaded to the device. Check the "Input
Specification" section for the details of the input format.

Once you have one or more input JSON files, run the `generate_source.py` script
to create a file that defines `decodeCanMessage`:

    ./generate_code.py --json signals.json > signals.pde

Drop the new `signals.pde` file in the `cantranslator` sketch folder, and it
should now compile.

If you have multiple CAN buses and want to define their signals and messages in
separate files, just pass multiple JSON files:

    ./generate_code.py --json highspeed.json --json mediumspeed.json > signals.pde

Note that the JSON files are parsed and merged, so if you want to define custom
handlers and states separately from the signal definition itself, you can store
them in separate files and they will be merged on import.

## Input Specification

The code in this repository requires a list of CAN messages with details of the
signals of interest, and their corresponding generic versions. The input format
is a JSON object like this:

    {"0x102": {
        "messages": {
            "ECM_z_5D2": {
                "id": 42,
                "signals": {
                    "StrAnglAct":
                        "id": 1,
                        "human_signal_name": "Steering wheel angle",
                        "generic_name": "SteeringWheelAngle",
                        "bit_position": 52,
                        "bit_size": 12,
                        "factor": 0.15392,
                        "offset": 0,
                        "value_handler": "float handleSteeringWheelAngle"},
                    "StrAnglSign":
                        "id": 2,
                        "human_signal_name": "Steering wheel angle sign",
                        "bit_position": 52,
                        "bit_size": 12},
                    "GrshftPos":
                        "id": 10,
                        "human_signal_name": "Gearshift Position",
                        "generic_name": "GearshiftPosition",
                        "bit_position": 41,
                        "bit_size": 0,
                        "states": {
                            "FIRST": 1,
                            "SECOND": 2,
                            "THIRD": 3,
                            "FOURTH": 4,
                            "REVERSE": 5,
                            "NEUTRAL": 6
                        }}
                ]
            "message_handler": "handleSteeringWheelMessage"
            }
        }
    }}

This is a list of CAN buses (the `0x102` is the unique bus address), messages in
each bus and a list of signals within each message. The attributes of a signal
are:

`name` - The official name of the signal - often a terse spelling.
    Optional - just used to be able to reference back to original documentation
    from this list.

`id` - A globally unique, numerical ID for the signal.

`human_signal_name` - A more friendly, human readable version of the signal's
    name. Optional - just used in comments so the generated source is clearer.

`generic_name` - The name of the associated generic signal name (from the OpenXC
        specification) that this should be translated to. Optional - if not
        specified, the signal is read and stored in memory, but not sent to the
        output bus. This is handy for combining the value of multiple signals
        into a composite measurement such as steering wheel angle with its sign.

`bit_position` - The staring bit position of this signal within the message.

`bit_size` - The width in bits of the signal.

`factor` - The signal value is multiplied by this if set. Optional.

`offset` - This is added to the signal value if set. Optional.

`value_handler` - The return type and name of a function that will be compiled
        with the sketch and should be applied to the signal's value after the
        normal translation. Optional - see the "Custom Handlers" section for
        more.

`message_handler` - The name of a function that will be compiled with the sketch
    and should be applied to the entire raw message value. No other operations
    are performed on the data if this type of handler is used. Optional - see
    the "Custom Handlers" section for more.

`states` - For state values, this is a mapping between the raw states (usually
    an integer) and the corresponding state in the generic signal.

## Custom Handlers

The default handler for each signal is a simple passthrough, translating the
signal's ID to an abstracted name (e.g. `SteeringWheelAngle`) and its value from
engineering units to something more usable. Some signals require additional
processing that you may wish to do within the translator and not on the host
device. Other signals may need to be combined to make a composite signal that's
more meaningful to developers.

An good example is steering wheel angle. For an app developer to get a value
that ranges from e.g. -350 to +350, we need to combine two different signals -
the angle and the sign. If you want to make this combination happen inside the
translator, you can use a custom handler.

You may also need a custom handler to return a value of a type other than float.
A handler is provided for dealing with boolean values, the `booleanHandler` - if
you specify that as your signal's `value_handler` the resulting JSON will
contain `true` for 1.0 and `false` for 0.0. If you want to translate integer
state values to string names (for parsing as an enum, for example) you will need
to write a value handler that returns a `char*`.

There are three levels of custom handlers:

* Message handlers - use these for custom processing of the entire CAN message.
* Signal handlers - use these for custom processing of one signal
* Value handlers - use these for making non-standard transformations to a signal
  value

For this example, we want to modify the value of `SteeringWheelAngle` by setting
the sign positive or negative based on the value of the other signal
(`StrAnglSign`). Every time a CAN signal is received, the new value is stored in
memory. Our custom handler `handleSteeringWheelAngle` will use that to adjust
the raw steering wheel angle value.

    float handleSteeringWheelAngle(CanSignal* signal, CanSignal* signals,
            float value, bool* send) {
        if(signal->lastValue == 0) {
            // left turn
            value *= -1;
        }
        return value;
    }

The valid return types for value handlers are `bool`, `float` and `char*` - the
function prototype must match one of:

    char* customHandler(CanSignal* signal, CanSignal* signals, float value,
            bool* send);

    float customHandler(CanSignal* signal, CanSignal* signals, float value,
            bool* send);

    bool customHandler(CanSignal* signal, CanSignal* signals, float value,
            bool* send);

where `signal` is a pointer to the `CanSignal` this is handling, `signals` is a
an array of all signals, `value` is the raw value from CAN and `send` is a flag
to indicate if this should be sent over USB.

The `bool* send` parameter is a pointer to a `bool` you can flip to `false` if
this signal value need not be sent over USB. This can be useful if you don't
want to keep notifying the same status over and over again, but only in the
event of a change in value (you can use the `lastValue` field on the CanSignal
object to determine if this is true).

A known issue with this method is that there is no guarantee that the last value
of another signal arrived in the message or before/after the value you're
current modifying. For steering wheel angle, that's probably OK - for other
signals, not so much.

If you need greater precision, you can provide a custom handler for the entire
message to guarantee they arrived together. You can generate 0, 1 or many
translated messages from one call to your handler function.

    void handleSteeringWheelMessage(uint8_t* data, CanSignal* signals) {
        float steeringWheelAngle = decodeCanSignal(&signals[1], data);
        float steeringWheelSign = decodeCanSignal(&signals[2], data);

        float finalValue = steeringWheelAngle;
        if(steeringWheelSign == 0) {
            // left turn
            finalValue *= -1;
        }

        char* message = generateJson(signals[1], finalValue);
        sendMessage((uint8_t*) message, strlen(message));
    }

## Sketch Generation

With this JSON list in hand, you next need to generate the C source code that
defines a `decodeCanMessage` function that can process the signals you've
defined. The generated source is a conversion of your JSON to an array of
C-structs, ready to be read by the translator at runtime.

To generate code, we've provided the `generate_code.py` script. Use it like so:

    $ generate_code.py signals.json > cantranslator/signals.pde

then rebuild your sketch - everything should build properly now.

Don't add anything else to this file - it's derivative of the master JSON, and
should be able to be wiped and recreated at any time.

### Canoe

If you use Canoe to store your "gold standard" CAN signal definitions, you may
be able to use the included `xml_to_json.py` script to make your JSON for you.
First, export the Canoe .dbc file as XML. Run the conversion script like this:

    $ xml_to_json.py signals.xml signal_mapping.txt build/signals.json

The `signal_mapping.txt` file is a simple mapping of the signal names that we
are looking for in the XML and a unique numerical ID to associate it
with.

## Output Specification

The microcontroller has a second USB controller operating in USB device mode. It
sends the generic vehicle data over via bulk USB transfer as packed JSON.

If USB throughput becomes an issue, the wire format can be optimized in two
ways:

* Use previously agreed upon numeric identifiers for signals instead of English
  names.
* Serialize to a binary protocol with Apache Thrift, or Google Protocol
  Buffers or ASN.1.

There are two valid message types - single valued and event.

### Single Valued

The expected format of a single valued message is:

    {"name": "SteeringWheelAngle", "value": 45}

### Event

The expected format of an event message is:

    {"name": "SteeringWheelAngle", "value": "up", "event": "pressed"}

This format is good for something like a button even, where there are two
discrete pieces of information in the measurement.

## API

This is the list of signals officially supported by the Android library.

<dl>
    <dt>steering_wheel_angle</dt>
    <dd>-400 to +400 degrees</dd>

    <dt>powertrain_torque</dt>
    <dd>-500 to 1500 Nm</dd>

    <dt>engine_speed<dt>
    <dd>0 to 16382 RPM</dd>

    <dt>vehicle_speed</dt>
    <dd>0 to 655 Km/h</dd>

    <dt>accelerator_pedal_position</dt>
    <dd>0 to 100%</dd>

    <dt>parking_brake_status</dt>
    <dd>Boolean (true == brake engaged)</dd>

    <dt>brake_pedal_status</dt>
    <dd>Boolean (True == pedal pressed)</dd>

    <dt>transmission_gear_position</dt>
    <dd>States: 1, 2, 3, 4, 5, 6, 7, 8, R, N</dd>

    <dt>odometer</dt>
    <dd>0 to 16777214 Km</dd>

    <dt>ignition_status</dt>
    <dd>States: off, accessory, run, start</dd>

    <dt>fuel_level</dt>
    <dd>0 - 204.6 L</dd>

    <dt>door_status</dt>
    <dd>Events: one event type per door, value is boolean (true == ajar)</dd>

    <dt>headlamp_status</dt>
    <dd>States: off, dipped, main</dd>

    <dt>windshield_wiper_speed</dt>
    <dd>0 to 31</dd>

    <dt>latitude</dt>
    <dd>-89.0 to 89.0 degrees</dd>

    <dt>longitude</dt>
    <dd>-179.0 to 179.0 degrees</dd>
</dl>

