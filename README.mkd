CAN Translation Module
=========================

## Old Requirements

The signal definition to Arduino sketch converison process (done with the
Makefile) requires the IntelHex Python package.


## New Requirements

The CAN translation module code runs on an Arudino-compatible Microcontroller
connected to one or more CAN buses. It receives either all CAN messages or a
filtered subset, performs any unit conversion or factoring required and outputs
a generic version to a USB interface.

## Input Specification

The code in this repository requires a list of CAN messages with details of the
signals of interest, and their corresponding generic versions. The input format
is a JSON object like this:

    {"messages": {
        "ECM_z_5D2": {
            "id": 42,
            "signals": [
                {"name": "StrAnglAct",
                    "id": 1,
                    "human_signal_name": "Steering wheel angle",
                    "generic_name": "SteeringWheelAngle",
                    "bit_position": 52,
                    "bit_size": 12,
                    "factor": 0.15392,
                    "offset": 0,
                    "value_handler": "handleSteeringWheelAngle"},
                {"name": "StrAnglSign",
                    "id": 2,
                    "human_signal_name": "Steering wheel angle sign",
                    "bit_position": 52,
                    "bit_size": 12},
                {"name": "GrshftPos",
                    "id": 10,
                    "human_signal_name": "Gearshift Position",
                    "generic_name": "GearshiftPosition",
                    "bit_position": 41,
                    "bit_size": 0,
                    "states": {
                        "1": "1st",
                        "2": "2nd",
                        "3": "3rd",
                        "4": "4th",
                        "5": "Reverse",
                        "6": "Neutral"
                    }}
            ]
        }
    }}

TODO add definitions of state names, translate at this level

This is a list of CAN messages and a list of signals within each message. The
attributes of a signal are:

`name` - The official name of the signal - often a terse spelling.
    Optional - just used to be able to reference back to original documentation
    from this list.

`id` - A globally unique, numerical ID for the signal.

`human_signal_name` - A more friendly, human readable version of the signal's
    name. Optional - just used in comments so the generated source is clearer.

`generic_name` - The name of the associated generic signal name (from the OpenXC
        specification) that this should be translated to. Optional - if not
        specified, the signal is read and stored in memory, but not sent to the
        output bus. This is handy for combining the value of multiple signals
        into a composite measurement such as steering wheel angle with its sign.

`bit_position` - The staring bit position of this signal within the message.

`bit_size` - The width in bits of the signal.

`factor` - The signal value is multiplied by this if set. Optional.

`offset` - This is added to the signal value if set. Optional.

`value_handler` - The name of a function that will be compiled with the sketch
        and should be applied to the signal's value after the normal
        translation. Optional - see the "Custom Handlers" section for more.

`states` - For state values, this is a mapping between the raw states (usually
    an integer) and the corresponding state in the generic signal. TODO.

## Custom Handlers

The default handler for each signal is a simple passthrough, translating the
signal's ID to an abstracted name (e.g. `SteeringWheelAngle`) and its value from
engineering units to something more usable. Some signals require additional
processing that you may wish to do within the translator and not on the host
device. Other signals may need to be combined to make a composite signal that's
more meaningful to developers.

An good example is steering wheel angle. For an app developer to get a value
that ranges from e.g. -350 to +350, we need to combine two different signals -
the angle and the sign. If you want to make this combnation happen inside the
translator, you can use a custom handler.

There are three levels of custom handlers:

* Message handlers - use these for custom processing of the entire CAN message.
        TODO this might not be neccessary
* Signal handlers - use these for custom processing of one signal
* Value handlers - use these for making non-standard transformations to a signal
  value

For this example, we want to modify the value of `SteeringWheelAngle` by setting
the sign positive or negative based on the value of the other signal
(`StrAnglSign`). Every time a CAN signal is received, the new value is stored in
memory. Our custom handler `handleSteeringWheelAngle` will use that to adjust
the raw steering wheel angle value.

    float handleSteeringWheelAngle(CanSignal* signal, CanSignal* signals,
            float value) {
        if(signals[2].lastValue == 0) {
            // left turn
            value *= -1;
        }
        return value;
    }

A known issue with this method is that there is no guarantee that the last value
of another signal arrived in the message or before/after the value you're
current modifying. For steering wheel angle, that's probably OK - for other
signals, not so much.

If you need greater precision, you can provide a custom handler for the entire
message to guarantee they arrived together. You can generate 0, 1 or many
translated messages from one call to your handler function.

    void handleSteeringWheelMessage(uint8_t* data) {
        float steeringWheelAngle = decodeCanSignal(SIGNALS[1], data);
        float steeringWheelSign = decodeCanSignal(SIGNALS[2], data);

        float finalValue = steeringWheelAngle;
        if(steeringWheelSign == 0) {
            // left turn
            finalValue *= -1;
        }

        char* message = generateJson(SIGNALS[1], finalValue);
        sendMessage((uint8_t*) message, strlen(message));
    }

## Sketch Generation

With this JSON list in hand, run the Makefile to generate a C source file
version that is accessible from the CAN translation sketch. Don't add anything
else to this file - it's derivitive of the master JSON, and can be wiped and
recreated at any time.

The generated source is a conversion of your JSON to an array of C-structs,
ready to be read by the translator at runtime.

To generate code, we've provided the `generate_code.py` script. Use it like so:

    $ generate_code.py signals.json > cantranslator/signals.pde

then rebuild your sketch - everything should build properly now.

### Canoe

If you use Canoe to store your "gold standard" CAN signal definitions, you may
be able to use the included `xml_to_json.py` script to make your JSON for you.
First, export the Canoe .dbc file as XML. Run the conversion script like this:

    $ xml_to_json.py signals.xml signal_mapping.txt build/signals.json

The `signal_mapping.txt` file is a simple mapping of the signal names that we
are looking for in the XML and a unique numerical ID to assicate it
with.

## Output Specification

The microcontroller has a second USB controller operating in USB device mode. It
sends the generic vehicle data over via bulk USB transfer as packed JSON.

The expected format is:

    {"name": "SteeringWheelAngle",
        "value": 45}

If USB throughput becomes an issue, the wire format can be optimized in two
ways:

* Use previously agreed upon numeric identifiers for signals instead of English
  names.
* Serialize to a binary protocol with Apache Thrift, or Goole Protocol
  Buffers or ASN.1.
